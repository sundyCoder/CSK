一 对象的种类
栈对象
堆对象
全局对象
静态局部对象:
无名对象:没有名字，一次性析构的对象。
常量对象
对象引用
对象指针


例程1：
#include <iostream>
using namespace std;

class C{
	int data;
	const int t;
public:
	C():data(0),t(0){
		cout<<"C()"<<endl;
	}

	C(int d):data(d),t(0){
		cout<<"C("<<data<<")"<<endl;
	}

	~C(){
			cout<<"~C("<<data<<")"<<endl;
		}

	void show(){
		data++;
		cout<<"data="<<data<<endl;
	}

	void show() const{  //常函数不能修改成员变量
			//data++; //error
			cout<<"const data="<<data<<endl;
		}

};

/*void C(int m){
	cout<<"ok"<<endl;
}*/

/*void fn(){
	C c3(30); //stack 栈对象
}

void gn(){
	static C c4(40); //data C4静态局部对象 ,创建和初始化一次
}*/

int main(){
	/*C c;     //stack c为栈对象     2

	cout<<"==================="<<endl;
	C *c1= new C(10);//heap 3 new是一个运算符，new C(20)在堆中创建一个无名对象，然后让c1指向该对象.
											  //此对象的却婵占湫枰手动释放，不能被系统析构
												//c1为对象指针
	delete c1;

	fn();            //4
	gn();							//5
	gn(); //虽然调用了两次gn但是只创建了一个对象 //data*/

	cout<<"==================="<<endl;
	/*C::C().show();  //无名对象 (临时对象),如果不用此无名对象之后，立马析构.
	C(50);   */    //相当于调用构造函数，如果有一个全局函数和某一个构造函数相同，则会调用全局函数

	//C; //error
	const C c;
	c.show();   //常对象只能调用常函数

	C c6;
	c6.show();  //普通对象既可以调用常函数，又可以调用普通函数。
	cout<<"==================="<<endl;

	/*
	cout<<"sizeof(c1)="<<sizeof(c1)<<endl;
	cout<<"sizeof(C)="<<sizeof(C)<<endl;*/
	return 0;
}

//C C2(20);//全局区，在数据段  1

二 对象引用
//1. &i取地址  2. 3&4 按位与  3 . a>0 && b<0 逻辑与  4 . int &i = j; 定义一个应用类型
#include <iostream>
using namespace std;

void change(int &n){
	++n;
}

class D{
	int data;
public:
	D(int d = 0):data(d){
		cout<<"C("<<data<<endl;
	};

	~D(){
			cout<<"~C("<<data<<endl;
		};
};

int main(){
	int i = 3;
	int &j = i; //j就是i的引用(别名)，j和i的地址相同,是同一个变量,一个地址映射多个名字
	change(j);
	cout<<"i="<<i<<",j="<<j<<endl;

	D c1 = 10; //当类的成员只有一个数据成员时，可以这样写
	//D &c2;   //error
	D &c2 = c1; //引用必须进行初始化,对象的引用不会产生对象的拷贝

	return 0;
}


例程2

#include <iostream>
using namespace std;

class A{
	int data;
public:
	/*A():data(0){
		cout<<"A()"<<endl;
	};*/
	A(int i =0):data(i){
		cout<<"A("<<data<<")"<<endl;
	}

	~A(){
		cout<<"~A("<<data<<")"<<endl;
		}

	void show(){
		cout<<"data="<<data<<endl;
	}
};


int main(){
//	A a;
//	A a2(2);
//	A a3(); // function declare

	/*
	A a4 = 4;   //A(4)  //a4,a5,a6等价
	a4.show();
	A a5 = A(5); //A(5) 这条语句本身只创建一个对象，但是编译器优化了,只创建一个。
	a5.show();
	A a6 = (A)6; //类型转换
	a6.show();
	*/

/*
	//类型转换的两种方法
	//（类型） 变量     类型(变量)
	double d = 4;
	double d2 = (double)4;
	double d3 = double(6);
	cout<<d<<d2<<d3<<endl;
*/

	A a7;
	a7 = A(7);  //分开写就创建了两个对象。
	a7.show();
	return 0;
}

三 对比一下两种情况
 (1) A a5 = A(5); //A(5) 这条语句本身只创建一个对象，但是编译器优化了,只创建一个。
 (2) A a7;
     a7 = A(7);  //分开写就创建了两个对象。








